import BN from 'bn.js';
export { default as BN } from 'bn.js';
import Long from 'long';
export { default as Long } from 'long';

//  Copyright (C) 2018 Zilliqa
//
//  This file is part of Zilliqa-Javascript-Library.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
/**
 * intToHexArray
 *
 * @param {number} int - the number to be converted to hex
 * @param {number)} size - the desired width of the hex value. will pad.
 *
 * @returns {string[]}
 */
var intToHexArray = function (int, size) {
    var hex = [];
    var hexRep = [];
    var hexVal = int.toString(16);
    // TODO: this really needs to be refactored.
    for (var i = 0; i < hexVal.length; i++) {
        hexRep[i] = hexVal[i].toString();
    }
    for (var i = 0; i < size - hexVal.length; i++) {
        hex.push('0');
    }
    for (var i = 0; i < hexVal.length; i++) {
        hex.push(hexRep[i]);
    }
    return hex;
};
/**
 * intToByteArray
 *
 * Converts a number to Uint8Array
 *
 * @param {number} num
 * @param {number} size
 *
 * @returns {Uint8Array}
 */
var intToByteArray = function (num, size) {
    var x = num;
    var res = [];
    while (x > 0) {
        res.push(x & 255);
        x = x >> 8;
    }
    var pad = size - res.length;
    for (var i = 0; i < pad; i++) {
        res.unshift(0);
    }
    return Uint8Array.from(res);
};
/**
 * hexToByteArray
 *
 * Convers a hex string to a Uint8Array
 *
 * @param {string} hex
 * @returns {Uint8Array}
 */
var hexToByteArray = function (hex) {
    var res = new Uint8Array(hex.length / 2);
    for (var i = 0; i < hex.length; i += 2) {
        res[i / 2] = parseInt(hex.substring(i, i + 2), 16);
    }
    return res;
};
/**
 * hexToIntArray
 *
 * @param {string} hex
 * @returns {number[]}
 */
var hexToIntArray = function (hex) {
    if (!hex || !isHex(hex)) {
        return [];
    }
    var res = [];
    for (var i = 0; i < hex.length; i++) {
        var c = hex.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        hi ? res.push(hi, lo) : res.push(lo);
    }
    return res;
};
/**
 * pack
 *
 * Takes two 16-bit integers and combines them. Used to compute version.
 *
 * @param {number} a
 * @param {number} b
 *
 * @returns {number} - a 32-bit number
 */
var pack = function (a, b) {
    if (a >> 16 > 0 || b >> 16 > 0) {
        throw new Error('Both a and b must be 16 bits or less');
    }
    return (a << 16) + b;
};
/**
 * compareBytes
 *
 * A constant time HMAC comparison function.
 *
 * @param {string} a
 * @param {string} b
 * @returns {boolean}
 */
var isEqual = function (a, b) {
    var bzA = hexToIntArray(a);
    var bzB = hexToIntArray(b);
    if (bzA.length !== bzB.length) {
        return false;
    }
    var result = 0;
    for (var i = 0; i < bzA.length; i++) {
        result |= bzA[i] ^ bzB[i];
    }
    return result === 0;
};
/**
 * isHex
 *
 * @param {string} str - string to be tested
 * @returns {boolean}
 */
var isHex = function (str) {
    var plain = str.replace('0x', '');
    return /[0-9a-f]*$/i.test(plain);
};

var bytes = /*#__PURE__*/Object.freeze({
  intToHexArray: intToHexArray,
  intToByteArray: intToByteArray,
  hexToByteArray: hexToByteArray,
  hexToIntArray: hexToIntArray,
  pack: pack,
  isEqual: isEqual,
  isHex: isHex
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

//  Copyright (C) 2018 Zilliqa
var isAddress = function (address) {
    return isByteString(address, 40);
};
var isBech32 = function (raw) {
    return !!raw.match(/^zil1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$/);
};
var isBase58 = function (raw) {
    return !!raw.match(/^[1-9ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/);
};
var isPrivateKey = function (privateKey) {
    return isByteString(privateKey, 64);
};
var isPubKey = function (pubKey) {
    return isByteString(pubKey, 66);
};
var isSignature = function (sig) {
    return isByteString(sig, 128);
};
var isByteString = function (str, len) {
    return !!str.replace('0x', '').match("^[0-9a-fA-F]{" + len + "}$");
};
var isNumber = function (x) {
    return typeof x === 'number';
};
var isBN = function (x) {
    return BN.isBN(x);
};
var isLong = function (x) {
    return Long.isLong(x);
};
var isString = function (x) {
    return typeof x === 'string';
};
var isPlainObject = function (x) {
    if (typeof x === 'object' && x !== null) {
        var proto = Object.getPrototypeOf(x);
        return proto === Object.prototype || proto === null;
    }
    return false;
};
var PRAGMA_REQUIRED = '@@ZJS_REQUIRED@@';
var required = function (fn) {
    if (typeof fn === 'function') {
        return Object.defineProperty(fn, 'required', {
            value: PRAGMA_REQUIRED,
        });
    }
    throw new Error('fn is not a function');
};
var matchesObject = function (x, test) {
    var e_1, _a;
    if (isPlainObject(x)) {
        for (var key in test) {
            if (test.hasOwnProperty(key)) {
                try {
                    for (var _b = (e_1 = void 0, __values(test[key])), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var tester = _c.value;
                        var value = x[key];
                        if (typeof value === 'undefined' && tester.required) {
                            throw new Error('Key not found: ' + key);
                        }
                        else {
                            continue;
                        }
                        if (typeof tester !== 'function') {
                            throw new Error('Validator is not a function');
                        }
                        if (!tester(value)) {
                            throw new Error('Validation failed for ' + key);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    }
    return true;
};

var validation = /*#__PURE__*/Object.freeze({
  isAddress: isAddress,
  isBech32: isBech32,
  isBase58: isBase58,
  isPrivateKey: isPrivateKey,
  isPubKey: isPubKey,
  isSignature: isSignature,
  isByteString: isByteString,
  isNumber: isNumber,
  isBN: isBN,
  isLong: isLong,
  isString: isString,
  isPlainObject: isPlainObject,
  required: required,
  matchesObject: matchesObject
});

//  Copyright (C) 2018 Zilliqa
var Units;
(function (Units) {
    Units["Zil"] = "zil";
    Units["Li"] = "li";
    Units["Qa"] = "qa";
})(Units || (Units = {}));
var DEFAULT_OPTIONS = {
    pad: false,
};
var unitMap = new Map([
    [Units.Qa, '1'],
    [Units.Li, '1000000'],
    [Units.Zil, '1000000000000'],
]);
var numToStr = function (input) {
    if (typeof input === 'string') {
        if (!input.match(/^-?[0-9.]+$/)) {
            throw new Error("while converting number to string, invalid number value '" + input + "', should be a number matching (^-?[0-9.]+).");
        }
        return input;
    }
    else if (typeof input === 'number') {
        return String(input);
    }
    else if (BN.isBN(input)) {
        return input.toString(10);
    }
    throw new Error("while converting number to string, invalid number value '" + input + "' type " + typeof input + ".");
};
var fromQa = function (qa, unit, options) {
    if (options === void 0) { options = DEFAULT_OPTIONS; }
    if (unit === 'qa') {
        return qa.toString(10);
    }
    var baseStr = unitMap.get(unit);
    if (!baseStr) {
        throw new Error("No unit of type " + unit + " exists.");
    }
    var base = new BN(baseStr, 10);
    var baseNumDecimals = baseStr.length - 1;
    var fraction = qa
        .abs()
        .mod(base)
        .toString(10);
    // prepend 0s to the fraction half
    while (fraction.length < baseNumDecimals) {
        fraction = "0" + fraction;
    }
    if (!options.pad) {
        fraction = (fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1]);
    }
    var whole = qa.div(base).toString(10);
    return fraction === '0' ? "" + whole : whole + "." + fraction;
};
var toQa = function (input, unit) {
    var inputStr = numToStr(input);
    var baseStr = unitMap.get(unit);
    if (!baseStr) {
        throw new Error("No unit of type " + unit + " exists.");
    }
    var baseNumDecimals = baseStr.length - 1;
    var base = new BN(baseStr, 10);
    // Is it negative?
    var isNegative = inputStr.substring(0, 1) === '-';
    if (isNegative) {
        inputStr = inputStr.substring(1);
    }
    if (inputStr === '.') {
        throw new Error("Cannot convert " + inputStr + " to Qa.");
    }
    // Split it into a whole and fractional part
    var comps = inputStr.split('.'); // eslint-disable-line
    if (comps.length > 2) {
        throw new Error("Cannot convert " + inputStr + " to Qa.");
    }
    var _a = __read(comps, 2), whole = _a[0], fraction = _a[1];
    if (!whole) {
        whole = '0';
    }
    if (!fraction) {
        fraction = '0';
    }
    if (fraction.length > baseNumDecimals) {
        throw new Error("Cannot convert " + inputStr + " to Qa.");
    }
    while (fraction.length < baseNumDecimals) {
        fraction += '0';
    }
    var wholeBN = new BN(whole);
    var fractionBN = new BN(fraction);
    var wei = wholeBN.mul(base).add(fractionBN); // eslint-disable-line
    if (isNegative) {
        wei = wei.neg();
    }
    return new BN(wei.toString(10), 10);
};

var unit = /*#__PURE__*/Object.freeze({
  get Units () { return Units; },
  fromQa: fromQa,
  toQa: toQa
});

//  Copyright (C) 2018 Zilliqa

export { bytes, unit as units, validation };
//# sourceMappingURL=index.esm.js.map
