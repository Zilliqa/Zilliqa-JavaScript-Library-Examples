"use strict";
//  Copyright (C) 2018 Zilliqa
//
//  This file is part of Zilliqa-Javascript-Library.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var account_1 = require("@zilliqa-js/account");
var crypto_1 = require("@zilliqa-js/crypto");
var util_1 = require("@zilliqa-js/util");
var core_1 = require("@zilliqa-js/core");
var util_2 = require("./util");
var Blockchain = /** @class */ (function () {
    function Blockchain(provider, signer) {
        this.pendingErrorMap = {
            0: 'Transaction not found',
            1: 'Pending - Dispatched',
            2: 'Pending - Soft-confirmed (awaiting Tx block generation)',
            4: 'Pending - Nonce is higher than expected',
            5: 'Pending - Microblock gas limit exceeded',
            6: 'Pending - Consensus failure in network',
            3: 'Confirmed',
            10: 'Rejected - Transaction caused math error',
            11: 'Rejected - Scilla invocation error',
            12: 'Rejected - Contract account initialization error',
            13: 'Rejected - Invalid source account',
            14: 'Rejected - Gas limit higher than shard gas limit',
            15: 'Rejected - Unknown transaction type',
            16: 'Rejected - Transaction sent to wrong shard',
            17: 'Rejected - Contract & source account cross-shard issue',
            18: 'Rejected - Code size exceeded limit',
            19: 'Rejected - Transaction verification failed',
            20: 'Rejected - Gas limit too low',
            21: 'Rejected - Insufficient balance',
            22: 'Rejected - Insufficient gas to invoke Scilla checker',
            23: 'Rejected - Duplicate transaction exists',
            24: 'Rejected - Transaction with same nonce but same/higher gas price exists',
            25: 'Rejected - Invalid destination address',
            26: 'Rejected - Failed to add contract account to state',
            27: 'Rejected - Nonce is lower than expected',
            255: 'Rejected - Internal error',
        };
        this.transactionStatusMap = {
            0: { 0: 'Transaction not found', 1: ' Pending - Dispatched' },
            1: {
                2: 'Pending - Soft-confirmed (awaiting Tx block generation)',
                4: 'Pending - Nonce is higher than expected',
                5: 'Pending - Microblock gas limit exceeded',
                6: 'Pending - Consensus failure in network',
            },
            2: {
                3: 'Confirmed',
                10: 'Rejected - Transaction caused math error',
                11: 'Rejected - Scilla invocation error',
                12: 'Rejected - Contract account initialization error',
                13: 'Rejected - Invalid source account',
                14: 'Rejected - Gas limit higher than shard gas limit',
                15: 'Rejected - Unknown transaction type',
                16: 'Rejected - Transaction sent to wrong shard',
                17: 'Rejected - Contract & source account cross-shard issue',
                18: 'Rejected - Code size exceeded limit',
                19: 'Rejected - Transaction verification failed',
                20: 'Rejected - Gas limit too low',
                21: 'Rejected - Insufficient balance',
                22: 'Rejected - Insufficient gas to invoke Scilla checker',
                23: 'Rejected - Duplicate transaction exists',
                24: 'Rejected - Transaction with higher gas price exists',
                25: 'Rejected - Invalid destination address',
                26: 'Rejected - Failed to add contract account to state',
                27: 'Rejected - Nonce is lower than expected',
                255: 'Rejected - Internal error',
            },
        };
        this.provider = provider;
        this.provider.middleware.request.use(account_1.util.formatOutgoingTx, core_1.RPCMethod.CreateTransaction);
        this.signer = signer;
    }
    /**
     * getBlockChainInfo
     *
     * @returns {Promise<RPCResponse<BlockchainInfo, string>>}
     */
    Blockchain.prototype.getBlockChainInfo = function () {
        return this.provider.send(core_1.RPCMethod.GetBlockchainInfo);
    };
    /**
     * getShardingStructure
     *
     * @returns {Promise<RPCResponse<ShardingStructure, string>>}
     */
    Blockchain.prototype.getShardingStructure = function () {
        return this.provider.send(core_1.RPCMethod.GetShardingStructure);
    };
    /**
     * getDSBlock
     *
     * Get details of a Directory Service block by block number.
     *
     * @param {number} blockNum
     * @returns {Promise<RPCResponse<DsBlockObj, string>>}
     */
    Blockchain.prototype.getDSBlock = function (blockNum) {
        return this.provider.send(core_1.RPCMethod.GetDSBlock, blockNum.toString());
    };
    /**
     * getLatestDSBlock
     *
     * Get details of the most recent Directory Service block.
     *
     * @returns {Promise<RPCResponse<DsBlockObj, string>>}
     */
    Blockchain.prototype.getLatestDSBlock = function () {
        return this.provider.send(core_1.RPCMethod.GetLatestDSBlock);
    };
    /**
     * getNumDSBlocks
     *
     * Gets the number of DS blocks that the network has processed.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getNumDSBlocks = function () {
        return this.provider.send(core_1.RPCMethod.GetNumDSBlocks);
    };
    /**
     * getDSBlockRate
     *
     * Gets the average rate of DS blocks processed per second
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getDSBlockRate = function () {
        return this.provider.send(core_1.RPCMethod.GetDSBlockRate);
    };
    /**
     * getDSBlockListing
     *
     * Get a paginated list of Directory Service blocks. Pass in page number as
     * parameter. Returns a maxPages variable that specifies the max number of
     * pages. 1 - latest blocks, maxPages - oldest blocks.
     *
     * @param {number} max
     * @returns {Promise<RPCResponse<BlockList, string>>}
     */
    Blockchain.prototype.getDSBlockListing = function (max) {
        return this.provider.send(core_1.RPCMethod.DSBlockListing, max);
    };
    /**
     * getTxBlock
     *
     * Get details of a Transaction block by block number.
     *
     * @param {number} blockNum
     * @returns {Promise<RPCResponse<TxBlockObj, string>>}
     */
    Blockchain.prototype.getTxBlock = function (blockNum) {
        return this.provider.send(core_1.RPCMethod.GetTxBlock, blockNum.toString());
    };
    /**
     * getLatestTxBlock
     *
     * Get details of the most recent Transaction block.
     *
     * @returns {Promise<RPCResponse<TxBlockObj, string>>}
     */
    Blockchain.prototype.getLatestTxBlock = function () {
        return this.provider.send(core_1.RPCMethod.GetLatestTxBlock);
    };
    /**
     * getNumTxBlocks
     *
     * Gets the total number of TxBlocks.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getNumTxBlocks = function () {
        return this.provider.send(core_1.RPCMethod.GetNumTxBlocks);
    };
    /**
     * getTxBlockRate
     *
     * Gets the average number of Tx blocks per second.
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getTxBlockRate = function () {
        return this.provider.send(core_1.RPCMethod.GetTxBlockRate);
    };
    /**
     * getTxBlockListing
     *
     * Get a paginated list of Transaction blocks. Takes a page number as
     * parameter, where each page contains a list of 10 blocks (max). Returns
     * a maxPages variable that specifies the max number of pages. 1 - latest
     * blocks, maxPages - oldest blocks.
     *
     * @param {number} max
     * @returns {Promise<RPCResponse<BlockList, string>>}
     */
    Blockchain.prototype.getTxBlockListing = function (max) {
        return this.provider.send(core_1.RPCMethod.TxBlockListing, max);
    };
    /**
     * getNumTransactions
     *
     * Gets the number of transactions processed by the network so far.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getNumTransactions = function () {
        return this.provider.send(core_1.RPCMethod.GetNumTransactions);
    };
    /**
     * getTransactionRate
     *
     * Gets the number of transactions processed per second
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getTransactionRate = function () {
        return this.provider.send(core_1.RPCMethod.GetTransactionRate);
    };
    /**
     * getCurrentMiniEpoch
     *
     * Gets the current Tx Epoch.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getCurrentMiniEpoch = function () {
        return this.provider.send(core_1.RPCMethod.GetCurrentMiniEpoch);
    };
    /**
     * getCurrentDSEpoch
     *
     * Gets the current DS Epoch.
     *
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getCurrentDSEpoch = function () {
        return this.provider.send(core_1.RPCMethod.GetCurrentDSEpoch);
    };
    /**
     * getPrevDifficulty
     *
     * Gets shard difficulty for previous PoW round
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getPrevDifficulty = function () {
        return this.provider.send(core_1.RPCMethod.GetPrevDifficulty);
    };
    /**
     * getPrevDSDifficulty
     *
     * Gets DS difficulty for previous PoW round
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    Blockchain.prototype.getPrevDSDifficulty = function () {
        return this.provider.send(core_1.RPCMethod.GetPrevDSDifficulty);
    };
    /**
     * getTotalCoinSupply
     *
     * Returns the total supply (ZIL) of coins in the network.
     */
    Blockchain.prototype.getTotalCoinSupply = function () {
        return this.provider.send(core_1.RPCMethod.GetTotalCoinSupply);
    };
    /**
     * getMinerInfo
     *
     * Returns the mining nodes (i.e., the members of the DS committee and shards) at the specified DS block.
     *
     * Notes:
     * 1. Nodes owned by Zilliqa Research are omitted.
     * 2. dscommittee has no size field since the DS committee size is fixed for a given chain.
     * 3. For the Zilliqa Mainnet, this API is only available from DS block 5500 onwards.
     *
     */
    Blockchain.prototype.getMinerInfo = function (dsBlockNumber) {
        return this.provider.send(core_1.RPCMethod.GetMinerInfo, dsBlockNumber);
    };
    /**
     * createTransaction
     *
     * Creates a transaction and polls the lookup node for a transaction
     * receipt. The transaction is considered to be lost if it is not confirmed
     * within the timeout period.
     *
     * @param {Transaction} tx
     * @param {number} maxAttempts - (optional) number of times to poll before timing out
     * @param {number} number - (optional) interval in ms
     * @returns {Promise<Transaction>} - the Transaction that has been signed and
     * broadcasted to the network.
     */
    Blockchain.prototype.createTransaction = function (tx, maxAttempts, interval, blockConfirm) {
        if (maxAttempts === void 0) { maxAttempts = core_1.GET_TX_ATTEMPTS; }
        if (interval === void 0) { interval = 1000; }
        if (blockConfirm === void 0) { blockConfirm = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send(core_1.RPCMethod.CreateTransaction, tslib_1.__assign(tslib_1.__assign({}, tx.txParams), { priority: tx.toDS }))];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        if (blockConfirm) {
                            return [2 /*return*/, tx.blockConfirm(response.result.TranID, maxAttempts, interval)];
                        }
                        return [2 /*return*/, tx.confirm(response.result.TranID, maxAttempts, interval)];
                    case 2:
                        err_1 = _a.sent();
                        throw err_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // used together with signed batch
    // this method waits for each txn to confirm
    // see @createBatchTransactionWithoutConfirm for transactions without confirmation
    Blockchain.prototype.createBatchTransaction = function (signedTxList, maxAttempts, interval, blockConfirm) {
        if (maxAttempts === void 0) { maxAttempts = core_1.GET_TX_ATTEMPTS; }
        if (interval === void 0) { interval = 1000; }
        if (blockConfirm === void 0) { blockConfirm = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txParamsList, signedTxList_1, signedTxList_1_1, signedTx, response, batchResults, i, tx, txRes, _a, _b, _c, _d, err_2;
            var e_1, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _f.trys.push([0, 8, , 9]);
                        txParamsList = [];
                        try {
                            for (signedTxList_1 = tslib_1.__values(signedTxList), signedTxList_1_1 = signedTxList_1.next(); !signedTxList_1_1.done; signedTxList_1_1 = signedTxList_1.next()) {
                                signedTx = signedTxList_1_1.value;
                                if (signedTx.txParams.signature === undefined) {
                                    throw new Error('The transaction is not signed.');
                                }
                                txParamsList.push(tslib_1.__assign(tslib_1.__assign({}, signedTx.txParams), { priority: signedTx.toDS }));
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (signedTxList_1_1 && !signedTxList_1_1.done && (_e = signedTxList_1.return)) _e.call(signedTxList_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        return [4 /*yield*/, this.provider.sendBatch(core_1.RPCMethod.CreateTransaction, txParamsList)];
                    case 1:
                        response = _f.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        batchResults = [];
                        i = 0;
                        _f.label = 2;
                    case 2:
                        if (!(i < signedTxList.length)) return [3 /*break*/, 7];
                        tx = signedTxList[i];
                        txRes = response.batch_result[i];
                        if (!blockConfirm) return [3 /*break*/, 4];
                        _b = (_a = batchResults).push;
                        return [4 /*yield*/, tx.blockConfirm(txRes.result.TranID, maxAttempts, interval)];
                    case 3:
                        _b.apply(_a, [_f.sent()]);
                        return [3 /*break*/, 6];
                    case 4:
                        _d = (_c = batchResults).push;
                        return [4 /*yield*/, tx.confirm(txRes.result.TranID, maxAttempts, interval)];
                    case 5:
                        _d.apply(_c, [_f.sent()]);
                        _f.label = 6;
                    case 6:
                        i++;
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/, batchResults];
                    case 8:
                        err_2 = _f.sent();
                        throw err_2;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * createTransactionRaw
     *
     * Create a transaction by using a exist signed transaction payload
     * This payload may come form some offline signing software like ledger
     * Currently we haven't supported convert a singed transaction back to transaction param, so we won't perform
     * confirm logic here, but there is another convenient way to do so, can refer examples/createTransactionRaw.js
     *
     * @param payload
     */
    Blockchain.prototype.createTransactionRaw = function (payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tx, response, err_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        tx = JSON.parse(payload);
                        return [4 /*yield*/, this.provider.send(core_1.RPCMethod.CreateTransaction, tx)];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        return [2 /*return*/, response.result.TranID];
                    case 2:
                        err_3 = _a.sent();
                        throw err_3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Blockchain.prototype.createTransactionWithoutConfirm = function (tx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, err_4;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send(core_1.RPCMethod.CreateTransaction, tslib_1.__assign(tslib_1.__assign({}, tx.txParams), { priority: tx.toDS }))];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        tx.id = response.result.TranID;
                        return [2 /*return*/, tx];
                    case 2:
                        err_4 = _a.sent();
                        throw err_4;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // used together with signed batch
    Blockchain.prototype.createBatchTransactionWithoutConfirm = function (signedTxList) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txParamsList, signedTxList_2, signedTxList_2_1, signedTx, response, batchResults, i, tx, txRes, err_5;
            var e_2, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        txParamsList = [];
                        try {
                            for (signedTxList_2 = tslib_1.__values(signedTxList), signedTxList_2_1 = signedTxList_2.next(); !signedTxList_2_1.done; signedTxList_2_1 = signedTxList_2.next()) {
                                signedTx = signedTxList_2_1.value;
                                if (signedTx.txParams.signature === undefined) {
                                    throw new Error('The transaction is not signed.');
                                }
                                txParamsList.push(tslib_1.__assign(tslib_1.__assign({}, signedTx.txParams), { priority: signedTx.toDS }));
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (signedTxList_2_1 && !signedTxList_2_1.done && (_a = signedTxList_2.return)) _a.call(signedTxList_2);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return [4 /*yield*/, this.provider.sendBatch(core_1.RPCMethod.CreateTransaction, txParamsList)];
                    case 1:
                        response = _b.sent();
                        if (response.error) {
                            throw response.error;
                        }
                        batchResults = [];
                        for (i = 0; i < signedTxList.length; i++) {
                            tx = signedTxList[i];
                            txRes = response.batch_result[i];
                            tx.id = txRes.result.TranID;
                            batchResults.push(tx);
                        }
                        return [2 /*return*/, batchResults];
                    case 2:
                        err_5 = _b.sent();
                        throw err_5;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * getTransaction
     *
     * Retrieves a transaction from the blockchain by its hash. If the result
     * contains an Error, a rejected Promise is returned with the erorr message.
     * If it does not contained an error, but `receipt.success` is `false`, then
     * a rejected Transaction instance is returned.
     *
     * @param {string} txHash
     * @returns {Promise<Transaction>}
     */
    Blockchain.prototype.getTransaction = function (txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, err_6;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send(core_1.RPCMethod.GetTransaction, txHash)];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            return [2 /*return*/, Promise.reject(response.error)];
                        }
                        return [2 /*return*/, response.result.receipt.success
                                ? account_1.Transaction.confirm(util_2.toTxParams(response), this.provider)
                                : account_1.Transaction.reject(util_2.toTxParams(response), this.provider)];
                    case 2:
                        err_6 = _a.sent();
                        throw err_6;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the status of a specified transaction.
     * This API is available from Zilliqa `V7.0.0` onwards and supports all transaction statuses
     * (unconfirmed, confirmed, and rejected).
     *
     * @param txHash
     * @returns {Promise<TransactionStatusObj>}
     */
    Blockchain.prototype.getTransactionStatus = function (txHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, modificationState, status_1, err_7;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.provider.send(core_1.RPCMethod.GetTransactionStatus, txHash)];
                    case 1:
                        response = _a.sent();
                        if (response.error) {
                            return [2 /*return*/, Promise.reject(response.error)];
                        }
                        modificationState = response.result.modificationState;
                        status_1 = response.result.status;
                        response.result.statusMessage = this.transactionStatusMap[modificationState][status_1];
                        return [2 /*return*/, response.result];
                    case 2:
                        err_7 = _a.sent();
                        throw err_7;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * getRecentTransactions
     *
     * Gets a list of recent transactions
     *
     * @returns {Promise<RPCResponse<TxList, never>>}
     */
    Blockchain.prototype.getRecentTransactions = function () {
        return this.provider.send(core_1.RPCMethod.GetRecentTransactions);
    };
    /**
     * getTransactionsForTxBlock
     *
     * Gets all transactions for a given TxBlock, grouped by shard id
     *
     * @param {number} txBlock
     * @returns {Promise<RPCResponse<string[][], string>>}
     */
    Blockchain.prototype.getTransactionsForTxBlock = function (txBlock) {
        return this.provider.send(core_1.RPCMethod.GetTransactionsForTxBlock, txBlock.toString());
    };
    /**
     * getTxnBodiesForTxBlock
     *
     * @param {number} txBlock
     * @returns { romise<RPCResponse<TransactionObj[], string>>}
     */
    Blockchain.prototype.getTxnBodiesForTxBlock = function (txBlock) {
        return this.provider.send(core_1.RPCMethod.GetTxnBodiesForTxBlock, txBlock.toString());
    };
    /**
     * getNumTxnsTxEpoch
     *
     * Gets the number of transactions procesed for a given Tx Epoch.
     *
     * @param {number} epoch
     * @returns {Promise<RPCResponse<number, never>>}
     */
    Blockchain.prototype.getNumTxnsTxEpoch = function (epoch) {
        return this.provider.send(core_1.RPCMethod.GetNumTxnsTxEpoch, epoch);
    };
    /**
     * getNumTxnsDSEpoch
     *
     * Gets the number of transactions procesed for a given DS Epoch.
     *
     * @param {number} epoch
     * @returns {Promise<any>}
     */
    Blockchain.prototype.getNumTxnsDSEpoch = function (epoch) {
        return this.provider.send(core_1.RPCMethod.GetNumTxnsDSEpoch, epoch);
    };
    /**
     * getMinimumGasPrice
     *
     * Gets the numeric minimum gas price
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getMinimumGasPrice = function () {
        return this.provider.send(core_1.RPCMethod.GetMinimumGasPrice);
    };
    /**
     * getBalance
     *
     * Gets the balance of an account by address
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getBalance = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send(core_1.RPCMethod.GetBalance, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractCode - returns the smart contract code of a deployed contract.
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<{code: string }, string>>}
     */
    Blockchain.prototype.getSmartContractCode = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send(core_1.RPCMethod.GetSmartContractCode, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractInit
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<Value[], string>>}
     */
    Blockchain.prototype.getSmartContractInit = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send(core_1.RPCMethod.GetSmartContractInit, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractState - retrieves the entire state of a smart contract
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getSmartContractState = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send(core_1.RPCMethod.GetSmartContractState, address.replace('0x', '').toLowerCase());
    };
    /**
     * getSmartContractSubState - Queries the contract state, filtered by the variable names.
     * This function is the filtered version of `getSmartContractState`.
     * As `getSubState` performs the filtering, `variableName` of a field is required.
     * If the `subState` is not found, this returns a `null` response.
     *
     * @param {string} address
     * @param { string } variableName - variable name within the state
     * @param { string[] } indices - (optional) If the variable is of map type, you can specify an index (or indices)
     * @returns {Promise<RPCResponse<any, string>>}
     */
    Blockchain.prototype.getSmartContractSubState = function (addr, variableName, indices) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        if (!variableName) {
            throw new Error('Variable name required');
        }
        return this.provider.send(core_1.RPCMethod.GetSmartContractSubState, address.replace('0x', '').toLowerCase(), variableName, indices === undefined ? [] : indices);
    };
    /**
     * getSmartContractSubStateBatch - Quires the contract state using batch rpc.
     * @param reqs array of address variableName indices
     *  e.g ["5938fc8af82250ad6cf1da3bb92f4aa005cb2717","balances",['0x381f4008505e940ad7681ec3468a719060caf796']]
     * @returns
     */
    Blockchain.prototype.getSmartContractSubStateBatch = function (reqs) {
        return this.provider.sendBatch(core_1.RPCMethod.GetSmartContractSubState, reqs);
    };
    /**
     * getSmartContracts
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<ContractObj[], string>>}
     */
    Blockchain.prototype.getSmartContracts = function (addr) {
        var address = util_1.validation.isBech32(addr) ? crypto_1.fromBech32Address(addr) : addr;
        return this.provider.send(core_1.RPCMethod.GetSmartContracts, address.replace('0x', '').toLowerCase());
    };
    /**
     * getContractAddressFromTransactionID
     *
     * @param {string} txHash
     * @returns {Promise<RPCResponse<string, string>>}
     */
    Blockchain.prototype.getContractAddressFromTransactionID = function (txHash) {
        return this.provider.send(core_1.RPCMethod.GetContractAddressFromTransactionID, txHash);
    };
    tslib_1.__decorate([
        core_1.sign,
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [account_1.Transaction, Number, Number, Boolean]),
        tslib_1.__metadata("design:returntype", Promise)
    ], Blockchain.prototype, "createTransaction", null);
    tslib_1.__decorate([
        core_1.sign,
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [account_1.Transaction]),
        tslib_1.__metadata("design:returntype", Promise)
    ], Blockchain.prototype, "createTransactionWithoutConfirm", null);
    return Blockchain;
}());
exports.Blockchain = Blockchain;
//# sourceMappingURL=chain.js.map