import { Transaction, Wallet } from '@zilliqa-js/account';
import { ContractObj, Value } from '@zilliqa-js/contract';
import { BlockchainInfo, BlockList, DsBlockObj, TransactionStatusObj, Provider, RPCResponse, ShardingStructure, TransactionObj, MinerInfo, TxBlockObj, TxList, ZilliqaModule } from '@zilliqa-js/core';
export declare class Blockchain implements ZilliqaModule {
    signer: Wallet;
    provider: Provider;
    pendingErrorMap: {
        [key: number]: string;
    };
    transactionStatusMap: {
        [key: number]: {
            [key: number]: string;
        };
    };
    constructor(provider: Provider, signer: Wallet);
    /**
     * getBlockChainInfo
     *
     * @returns {Promise<RPCResponse<BlockchainInfo, string>>}
     */
    getBlockChainInfo(): Promise<RPCResponse<BlockchainInfo, string>>;
    /**
     * getShardingStructure
     *
     * @returns {Promise<RPCResponse<ShardingStructure, string>>}
     */
    getShardingStructure(): Promise<RPCResponse<ShardingStructure, string>>;
    /**
     * getDSBlock
     *
     * Get details of a Directory Service block by block number.
     *
     * @param {number} blockNum
     * @returns {Promise<RPCResponse<DsBlockObj, string>>}
     */
    getDSBlock(blockNum: number): Promise<RPCResponse<DsBlockObj, string>>;
    /**
     * getLatestDSBlock
     *
     * Get details of the most recent Directory Service block.
     *
     * @returns {Promise<RPCResponse<DsBlockObj, string>>}
     */
    getLatestDSBlock(): Promise<RPCResponse<DsBlockObj, string>>;
    /**
     * getNumDSBlocks
     *
     * Gets the number of DS blocks that the network has processed.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    getNumDSBlocks(): Promise<RPCResponse<string, string>>;
    /**
     * getDSBlockRate
     *
     * Gets the average rate of DS blocks processed per second
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    getDSBlockRate(): Promise<RPCResponse<number, string>>;
    /**
     * getDSBlockListing
     *
     * Get a paginated list of Directory Service blocks. Pass in page number as
     * parameter. Returns a maxPages variable that specifies the max number of
     * pages. 1 - latest blocks, maxPages - oldest blocks.
     *
     * @param {number} max
     * @returns {Promise<RPCResponse<BlockList, string>>}
     */
    getDSBlockListing(max: number): Promise<RPCResponse<BlockList, string>>;
    /**
     * getTxBlock
     *
     * Get details of a Transaction block by block number.
     *
     * @param {number} blockNum
     * @returns {Promise<RPCResponse<TxBlockObj, string>>}
     */
    getTxBlock(blockNum: number): Promise<RPCResponse<TxBlockObj, string>>;
    /**
     * getLatestTxBlock
     *
     * Get details of the most recent Transaction block.
     *
     * @returns {Promise<RPCResponse<TxBlockObj, string>>}
     */
    getLatestTxBlock(): Promise<RPCResponse<TxBlockObj, string>>;
    /**
     * getNumTxBlocks
     *
     * Gets the total number of TxBlocks.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    getNumTxBlocks(): Promise<RPCResponse<string, string>>;
    /**
     * getTxBlockRate
     *
     * Gets the average number of Tx blocks per second.
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    getTxBlockRate(): Promise<RPCResponse<number, string>>;
    /**
     * getTxBlockListing
     *
     * Get a paginated list of Transaction blocks. Takes a page number as
     * parameter, where each page contains a list of 10 blocks (max). Returns
     * a maxPages variable that specifies the max number of pages. 1 - latest
     * blocks, maxPages - oldest blocks.
     *
     * @param {number} max
     * @returns {Promise<RPCResponse<BlockList, string>>}
     */
    getTxBlockListing(max: number): Promise<RPCResponse<BlockList, string>>;
    /**
     * getNumTransactions
     *
     * Gets the number of transactions processed by the network so far.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    getNumTransactions(): Promise<RPCResponse<string, string>>;
    /**
     * getTransactionRate
     *
     * Gets the number of transactions processed per second
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    getTransactionRate(): Promise<RPCResponse<number, string>>;
    /**
     * getCurrentMiniEpoch
     *
     * Gets the current Tx Epoch.
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    getCurrentMiniEpoch(): Promise<RPCResponse<string, string>>;
    /**
     * getCurrentDSEpoch
     *
     * Gets the current DS Epoch.
     *
     * @returns {Promise<RPCResponse<any, string>>}
     */
    getCurrentDSEpoch(): Promise<RPCResponse<any, string>>;
    /**
     * getPrevDifficulty
     *
     * Gets shard difficulty for previous PoW round
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    getPrevDifficulty(): Promise<RPCResponse<number, string>>;
    /**
     * getPrevDSDifficulty
     *
     * Gets DS difficulty for previous PoW round
     *
     * @returns {Promise<RPCResponse<number, string>>}
     */
    getPrevDSDifficulty(): Promise<RPCResponse<number, string>>;
    /**
     * getTotalCoinSupply
     *
     * Returns the total supply (ZIL) of coins in the network.
     */
    getTotalCoinSupply(): Promise<RPCResponse<string, string>>;
    /**
     * getMinerInfo
     *
     * Returns the mining nodes (i.e., the members of the DS committee and shards) at the specified DS block.
     *
     * Notes:
     * 1. Nodes owned by Zilliqa Research are omitted.
     * 2. dscommittee has no size field since the DS committee size is fixed for a given chain.
     * 3. For the Zilliqa Mainnet, this API is only available from DS block 5500 onwards.
     *
     */
    getMinerInfo(dsBlockNumber: string): Promise<RPCResponse<MinerInfo, any>>;
    /**
     * createTransaction
     *
     * Creates a transaction and polls the lookup node for a transaction
     * receipt. The transaction is considered to be lost if it is not confirmed
     * within the timeout period.
     *
     * @param {Transaction} tx
     * @param {number} maxAttempts - (optional) number of times to poll before timing out
     * @param {number} number - (optional) interval in ms
     * @returns {Promise<Transaction>} - the Transaction that has been signed and
     * broadcasted to the network.
     */
    createTransaction(tx: Transaction, maxAttempts?: number, interval?: number, blockConfirm?: boolean): Promise<Transaction>;
    createBatchTransaction(signedTxList: Transaction[], maxAttempts?: number, interval?: number, blockConfirm?: boolean): Promise<Transaction[]>;
    /**
     * createTransactionRaw
     *
     * Create a transaction by using a exist signed transaction payload
     * This payload may come form some offline signing software like ledger
     * Currently we haven't supported convert a singed transaction back to transaction param, so we won't perform
     * confirm logic here, but there is another convenient way to do so, can refer examples/createTransactionRaw.js
     *
     * @param payload
     */
    createTransactionRaw(payload: string): Promise<string>;
    createTransactionWithoutConfirm(tx: Transaction): Promise<Transaction>;
    createBatchTransactionWithoutConfirm(signedTxList: Transaction[]): Promise<Transaction[]>;
    /**
     * getTransaction
     *
     * Retrieves a transaction from the blockchain by its hash. If the result
     * contains an Error, a rejected Promise is returned with the erorr message.
     * If it does not contained an error, but `receipt.success` is `false`, then
     * a rejected Transaction instance is returned.
     *
     * @param {string} txHash
     * @returns {Promise<Transaction>}
     */
    getTransaction(txHash: string): Promise<Transaction>;
    /**
     * Returns the status of a specified transaction.
     * This API is available from Zilliqa `V7.0.0` onwards and supports all transaction statuses
     * (unconfirmed, confirmed, and rejected).
     *
     * @param txHash
     * @returns {Promise<TransactionStatusObj>}
     */
    getTransactionStatus(txHash: string): Promise<TransactionStatusObj>;
    /**
     * getRecentTransactions
     *
     * Gets a list of recent transactions
     *
     * @returns {Promise<RPCResponse<TxList, never>>}
     */
    getRecentTransactions(): Promise<RPCResponse<TxList, never>>;
    /**
     * getTransactionsForTxBlock
     *
     * Gets all transactions for a given TxBlock, grouped by shard id
     *
     * @param {number} txBlock
     * @returns {Promise<RPCResponse<string[][], string>>}
     */
    getTransactionsForTxBlock(txBlock: number): Promise<RPCResponse<string[][], string>>;
    /**
     * getTxnBodiesForTxBlock
     *
     * @param {number} txBlock
     * @returns { romise<RPCResponse<TransactionObj[], string>>}
     */
    getTxnBodiesForTxBlock(txBlock: number): Promise<RPCResponse<TransactionObj[], string>>;
    /**
     * getNumTxnsTxEpoch
     *
     * Gets the number of transactions procesed for a given Tx Epoch.
     *
     * @param {number} epoch
     * @returns {Promise<RPCResponse<number, never>>}
     */
    getNumTxnsTxEpoch(epoch: number): Promise<RPCResponse<string, string>>;
    /**
     * getNumTxnsDSEpoch
     *
     * Gets the number of transactions procesed for a given DS Epoch.
     *
     * @param {number} epoch
     * @returns {Promise<any>}
     */
    getNumTxnsDSEpoch(epoch: number): Promise<RPCResponse<string, string>>;
    /**
     * getMinimumGasPrice
     *
     * Gets the numeric minimum gas price
     *
     * @returns {Promise<RPCResponse<string, string>>}
     */
    getMinimumGasPrice(): Promise<RPCResponse<string, string>>;
    /**
     * getBalance
     *
     * Gets the balance of an account by address
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<any, string>>}
     */
    getBalance(addr: string): Promise<RPCResponse<any, string>>;
    /**
     * getSmartContractCode - returns the smart contract code of a deployed contract.
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<{code: string }, string>>}
     */
    getSmartContractCode(addr: string): Promise<RPCResponse<{
        code: string;
    }, string>>;
    /**
     * getSmartContractInit
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<Value[], string>>}
     */
    getSmartContractInit(addr: string): Promise<RPCResponse<Value[], string>>;
    /**
     * getSmartContractState - retrieves the entire state of a smart contract
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<any, string>>}
     */
    getSmartContractState(addr: string): Promise<RPCResponse<any, string>>;
    /**
     * getSmartContractSubState - Queries the contract state, filtered by the variable names.
     * This function is the filtered version of `getSmartContractState`.
     * As `getSubState` performs the filtering, `variableName` of a field is required.
     * If the `subState` is not found, this returns a `null` response.
     *
     * @param {string} address
     * @param { string } variableName - variable name within the state
     * @param { string[] } indices - (optional) If the variable is of map type, you can specify an index (or indices)
     * @returns {Promise<RPCResponse<any, string>>}
     */
    getSmartContractSubState(addr: string, variableName: string, indices?: string[]): Promise<RPCResponse<any, string>>;
    /**
     * getSmartContractSubStateBatch - Quires the contract state using batch rpc.
     * @param reqs array of address variableName indices
     *  e.g ["5938fc8af82250ad6cf1da3bb92f4aa005cb2717","balances",['0x381f4008505e940ad7681ec3468a719060caf796']]
     * @returns
     */
    getSmartContractSubStateBatch(reqs: any[]): Promise<RPCResponse<any, any>>;
    /**
     * getSmartContracts
     *
     * @param {string} address
     * @returns {Promise<RPCResponse<ContractObj[], string>>}
     */
    getSmartContracts(addr: string): Promise<RPCResponse<ContractObj[], string>>;
    /**
     * getContractAddressFromTransactionID
     *
     * @param {string} txHash
     * @returns {Promise<RPCResponse<string, string>>}
     */
    getContractAddressFromTransactionID(txHash: string): Promise<RPCResponse<string, string>>;
}
//# sourceMappingURL=chain.d.ts.map