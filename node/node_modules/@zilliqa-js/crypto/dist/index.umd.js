(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@zilliqa-js/util'), require('elliptic'), require('hash.js'), require('hmac-drbg'), require('aes-js'), require('pbkdf2'), require('scrypt-js'), require('uuid')) :
  typeof define === 'function' && define.amd ? define(['exports', '@zilliqa-js/util', 'elliptic', 'hash.js', 'hmac-drbg', 'aes-js', 'pbkdf2', 'scrypt-js', 'uuid'], factory) :
  (factory((global.zjsCrypto = {}),global['@zilliqa-js/util'],global.elliptic,global.hash.js,global['hmac-drbg'],global['aes-js'],global.pbkdf2,global['scrypt-js'],global.uuid));
}(this, (function (exports,util,elliptic,hashjs,DRBG,aes,pbkdf2,scrypt,uuid) { 'use strict';

  elliptic = elliptic && elliptic.hasOwnProperty('default') ? elliptic['default'] : elliptic;
  hashjs = hashjs && hashjs.hasOwnProperty('default') ? hashjs['default'] : hashjs;
  DRBG = DRBG && DRBG.hasOwnProperty('default') ? DRBG['default'] : DRBG;
  aes = aes && aes.hasOwnProperty('default') ? aes['default'] : aes;
  scrypt = scrypt && scrypt.hasOwnProperty('default') ? scrypt['default'] : scrypt;
  uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid;

  //  Copyright (C) 2018 Zilliqa
  //
  //  This file is part of Zilliqa-Javascript-Library.
  //
  //  This program is free software: you can redistribute it and/or modify
  //  it under the terms of the GNU General Public License as published by
  //  the Free Software Foundation, either version 3 of the License, or
  //  (at your option) any later version.
  //
  //  This program is distributed in the hope that it will be useful,
  //  but WITHOUT ANY WARRANTY; without even the implied warranty of
  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  //  GNU General Public License for more details.
  //
  //  You should have received a copy of the GNU General Public License
  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.
  /**
   * randomBytes
   *
   * Uses JS-native CSPRNG to generate a specified number of bytes.
   * NOTE: this method throws if no PRNG is available.
   *
   * @param {number} bytes
   * @returns {string}
   */
  var randomBytes = function (bytes) {
      var randBz;
      if (typeof window !== 'undefined' &&
          window.crypto &&
          window.crypto.getRandomValues) {
          randBz = window.crypto.getRandomValues(new Uint8Array(bytes));
      }
      else if (typeof require !== 'undefined') {
          var b = Buffer.allocUnsafe(bytes);
          var sodium = require('sodium-native');
          sodium.randombytes_buf(b);
          randBz = new Uint8Array(b.buffer, b.byteOffset, b.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      else {
          throw new Error('Unable to generate safe random numbers.');
      }
      var randStr = '';
      for (var i = 0; i < bytes; i++) {
          randStr += ('00' + randBz[i].toString(16)).slice(-2);
      }
      return randStr;
  };

  //  Copyright (C) 2018 Zilliqa
  var Signature = /** @class */ (function () {
      function Signature(options) {
          this.r = typeof options.r === 'string' ? new util.BN(options.r, 16) : options.r;
          this.s = typeof options.s === 'string' ? new util.BN(options.s, 16) : options.s;
      }
      return Signature;
  }());

  //  Copyright (C) 2018 Zilliqa
  var secp256k1 = elliptic.ec('secp256k1');
  var curve = secp256k1.curve;
  var PRIVKEY_SIZE_BYTES = 32;
  // Public key is a point (x, y) on the curve.
  // Each coordinate requires 32 bytes.
  // In its compressed form it suffices to store the x co-ordinate
  // and the sign for y.
  // Hence a total of 33 bytes.
  var PUBKEY_COMPRESSED_SIZE_BYTES = 33;
  // Personalization string used for HMAC-DRBG instantiation.
  var ALG = Buffer.from('Schnorr+SHA256  ', 'ascii');
  // The length in bytes of the string above.
  var ALG_LEN = 16;
  // The length in bytes of entropy inputs to HMAC-DRBG
  var ENT_LEN = 32;
  var HEX_ENC = 'hex';
  /**
   * generatePrivateKey
   *
   * @returns {string} - the hex-encoded private key
   */
  var generatePrivateKey = function () {
      return secp256k1
          .genKeyPair({
          entropy: randomBytes(secp256k1.curve.n.byteLength()),
          entropyEnc: HEX_ENC,
          pers: 'zilliqajs+secp256k1+SHA256',
      })
          .getPrivate()
          .toString(16, PRIVKEY_SIZE_BYTES * 2);
  };
  /**
   * Hash (r | M).
   * @param {Buffer} msg
   * @param {BN} r
   *
   * @returns {Buffer}
   */
  var hash = function (q, pubkey, msg) {
      var sha256 = hashjs.sha256();
      var totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen
      var Q = q.toArrayLike(Buffer, 'be', 33);
      var B = Buffer.allocUnsafe(totalLength);
      Q.copy(B, 0);
      pubkey.copy(B, 33);
      msg.copy(B, 66);
      return new util.BN(sha256.update(B).digest('hex'), 16);
  };
  /**
   * sign
   *
   * @param {Buffer} msg
   * @param {Buffer} key
   * @param {Buffer} pubkey
   *
   * @returns {Signature}
   */
  var sign = function (msg, privKey, pubKey) {
      var prv = new util.BN(privKey);
      var drbg = getDRBG(msg);
      var len = curve.n.byteLength();
      var sig;
      while (!sig) {
          var k = new util.BN(drbg.generate(len));
          sig = trySign(msg, k, prv, pubKey);
      }
      return sig;
  };
  /**
   * trySign
   *
   * @param {Buffer} msg - the message to sign over
   * @param {BN} k - output of the HMAC-DRBG
   * @param {BN} privateKey - the private key
   * @param {Buffer} pubKey - the public key
   *
   * @returns {Signature | null =>}
   */
  var trySign = function (msg, k, privKey, pubKey) {
      if (privKey.isZero()) {
          throw new Error('Bad private key.');
      }
      if (privKey.gte(curve.n)) {
          throw new Error('Bad private key.');
      }
      // 1a. check that k is not 0
      if (k.isZero()) {
          return null;
      }
      // 1b. check that k is < the order of the group
      if (k.gte(curve.n)) {
          return null;
      }
      // 2. Compute commitment Q = kG, where g is the base point
      var Q = curve.g.mul(k);
      // convert the commitment to octets first
      var compressedQ = new util.BN(Q.encodeCompressed());
      // 3. Compute the challenge r = H(Q || pubKey || msg)
      // mod reduce the r value by the order of secp256k1, n
      var r = hash(compressedQ, pubKey, msg).umod(curve.n);
      var h = r.clone();
      if (h.isZero()) {
          return null;
      }
      // 4. Compute s = k - r * prv
      // 4a. Compute r * prv
      var s = h.imul(privKey).umod(curve.n);
      // 4b. Compute s = k - r * prv mod n
      s = k.isub(s).umod(curve.n);
      if (s.isZero()) {
          return null;
      }
      return new Signature({ r: r, s: s });
  };
  /**
   * Verify signature.
   *
   * @param {Buffer} msg
   * @param {Buffer} signature
   * @param {Buffer} key
   *
   * @returns {boolean}
   *
   * 1. Check if r,s is in [1, ..., order-1]
   * 2. Compute Q = sG + r*kpub
   * 3. If Q = O (the neutral point), return 0;
   * 4. r' = H(Q, kpub, m)
   * 5. return r' == r
   */
  var verify = function (msg, signature, key) {
      var sig = new Signature(signature);
      if (sig.s.isZero() || sig.r.isZero()) {
          throw new Error('Invalid signature');
      }
      if (sig.s.isNeg() || sig.r.isNeg()) {
          throw new Error('Invalid signature');
      }
      if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {
          throw new Error('Invalid signature');
      }
      var kpub = curve.decodePoint(key);
      if (!curve.validate(kpub)) {
          throw new Error('Invalid public key');
      }
      var l = kpub.mul(sig.r);
      var r = curve.g.mul(sig.s);
      var Q = l.add(r);
      if (Q.isInfinity()) {
          throw new Error('Invalid intermediate point.');
      }
      var compressedQ = new util.BN(Q.encodeCompressed());
      var r1 = hash(compressedQ, key, msg).umod(curve.n);
      if (r1.isZero()) {
          throw new Error('Invalid hash.');
      }
      return r1.eq(sig.r);
  };
  var toSignature = function (serialised) {
      var r = serialised.slice(0, 64);
      var s = serialised.slice(64);
      return new Signature({ r: r, s: s });
  };
  /**
   * Instantiate an HMAC-DRBG.
   *
   * @param {Buffer} msg - used as nonce
   *
   * @returns {DRBG}
   */
  var getDRBG = function (msg) {
      var entropy = randomBytes(ENT_LEN);
      var pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);
      Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);
      ALG.copy(pers, ENT_LEN);
      return new DRBG({
          hash: hashjs.sha256,
          entropy: entropy,
          nonce: msg,
          pers: pers,
      });
  };

  var schnorr = /*#__PURE__*/Object.freeze({
    generatePrivateKey: generatePrivateKey,
    hash: hash,
    sign: sign,
    trySign: trySign,
    verify: verify,
    toSignature: toSignature
  });

  //  Copyright (C) 2018 Zilliqa
  // This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript
  // Copyright (c) 2017 Pieter Wuille
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  // THE SOFTWARE.
  var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
  var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
  var polymod = function (values) {
      var chk = 1;
      // tslint:disable-next-line
      for (var p = 0; p < values.length; ++p) {
          var top_1 = chk >> 25;
          chk = ((chk & 0x1ffffff) << 5) ^ values[p];
          for (var i = 0; i < 5; ++i) {
              if ((top_1 >> i) & 1) {
                  chk ^= GENERATOR[i];
              }
          }
      }
      return chk;
  };
  var hrpExpand = function (hrp) {
      var ret = [];
      var p;
      for (p = 0; p < hrp.length; ++p) {
          ret.push(hrp.charCodeAt(p) >> 5);
      }
      ret.push(0);
      for (p = 0; p < hrp.length; ++p) {
          ret.push(hrp.charCodeAt(p) & 31);
      }
      return Buffer.from(ret);
  };
  function verifyChecksum(hrp, data) {
      return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;
  }
  function createChecksum(hrp, data) {
      var values = Buffer.concat([
          Buffer.from(hrpExpand(hrp)),
          data,
          Buffer.from([0, 0, 0, 0, 0, 0]),
      ]);
      // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
      var mod = polymod(values) ^ 1;
      var ret = [];
      for (var p = 0; p < 6; ++p) {
          ret.push((mod >> (5 * (5 - p))) & 31);
      }
      return Buffer.from(ret);
  }
  var encode = function (hrp, data) {
      var combined = Buffer.concat([data, createChecksum(hrp, data)]);
      var ret = hrp + '1';
      // tslint:disable-next-line
      for (var p = 0; p < combined.length; ++p) {
          ret += CHARSET.charAt(combined[p]);
      }
      return ret;
  };
  var decode = function (bechString) {
      var p;
      var hasLower = false;
      var hasUpper = false;
      for (p = 0; p < bechString.length; ++p) {
          if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {
              return null;
          }
          if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {
              hasLower = true;
          }
          if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {
              hasUpper = true;
          }
      }
      if (hasLower && hasUpper) {
          return null;
      }
      bechString = bechString.toLowerCase();
      var pos = bechString.lastIndexOf('1');
      if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {
          return null;
      }
      var hrp = bechString.substring(0, pos);
      var data = [];
      for (p = pos + 1; p < bechString.length; ++p) {
          var d = CHARSET.indexOf(bechString.charAt(p));
          if (d === -1) {
              return null;
          }
          data.push(d);
      }
      if (!verifyChecksum(hrp, Buffer.from(data))) {
          return null;
      }
      return { hrp: hrp, data: Buffer.from(data.slice(0, data.length - 6)) };
  };
  // HRP is the human-readable part of zilliqa bech32 addresses
  var HRP = 'zil';
  /**
   * convertBits
   *
   * groups buffers of a certain width to buffers of the desired width.
   *
   * For example, converts byte buffers to buffers of maximum 5 bit numbers,
   * padding those numbers as necessary. Necessary for encoding Ethereum-style
   * addresses as bech32 ones.
   *
   * @param {Buffer} data
   * @param {number} fromWidth
   * @param {number} toWidth
   * @param {boolean} pad
   * @returns {Buffer|null}
   */
  var convertBits = function (data, fromWidth, toWidth, pad) {
      if (pad === void 0) { pad = true; }
      var acc = 0;
      var bits = 0;
      var ret = [];
      var maxv = (1 << toWidth) - 1;
      // tslint:disable-next-line
      for (var p = 0; p < data.length; ++p) {
          var value = data[p];
          if (value < 0 || value >> fromWidth !== 0) {
              return null;
          }
          acc = (acc << fromWidth) | value;
          bits += fromWidth;
          while (bits >= toWidth) {
              bits -= toWidth;
              ret.push((acc >> bits) & maxv);
          }
      }
      if (pad) {
          if (bits > 0) {
              ret.push((acc << (toWidth - bits)) & maxv);
          }
      }
      else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
          return null;
      }
      return Buffer.from(ret);
  };
  /**
   * toBech32Address
   *
   * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa
   * address.
   *
   * The expected format is zil1<address><checksum> where address and checksum
   * are the result of bech32 encoding a Buffer containing the address bytes.
   *
   * @param {string} 20 byte canonical address
   * @returns {string} 38 char bech32 encoded zilliqa address
   */
  var toBech32Address = function (address) {
      if (!util.validation.isAddress(address)) {
          throw new Error('Invalid address format.');
      }
      var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);
      if (addrBz === null) {
          throw new Error('Could not convert byte Buffer to 5-bit Buffer');
      }
      return encode(HRP, addrBz);
  };
  /**
   * fromBech32Address
   *
   * @param {string} address - a valid Zilliqa bech32 address
   * @returns {string} a canonical 20-byte Ethereum-style address
   */
  var fromBech32Address = function (address) {
      var res = decode(address);
      if (res === null) {
          throw new Error('Invalid bech32 address');
      }
      var hrp = res.hrp, data = res.data;
      var shouldBe = HRP;
      if (hrp !== shouldBe) {
          throw new Error("Expected hrp to be " + shouldBe + " but got " + hrp);
      }
      var buf = convertBits(data, 5, 8, false);
      if (buf === null) {
          throw new Error('Could not convert buffer to bytes');
      }
      return toChecksumAddress(buf.toString('hex'));
  };

  //  Copyright (C) 2018 Zilliqa
  var secp256k1$1 = elliptic.ec('secp256k1');
  /**
   * getAddressFromPrivateKey
   *
   * takes a hex-encoded string (private key) and returns its corresponding
   * 20-byte hex-encoded address.
   *
   * @param {string} privateKey
   * @returns {string}
   */
  var getAddressFromPrivateKey = function (privateKey) {
      var normalizedPrviateKey = normalizePrivateKey(privateKey);
      var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');
      var pub = keyPair.getPublic(true, 'hex');
      return toChecksumAddress(hashjs
          .sha256()
          .update(pub, 'hex')
          .digest('hex')
          .slice(24));
  };
  /**
   * getPubKeyFromPrivateKey
   *
   * takes a hex-encoded string (private key) and returns its corresponding
   * hex-encoded 33-byte public key.
   *
   * @param {string} privateKey
   * @returns {string}
   */
  var getPubKeyFromPrivateKey = function (privateKey) {
      var normalizedPrviateKey = normalizePrivateKey(privateKey);
      var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');
      return keyPair.getPublic(true, 'hex');
  };
  /**
   * getAccountFrom0xPrivateKey
   *
   * Utility method for recovering account from 0x private key.
   * See https://github.com/Zilliqa/Zilliqa-JavaScript-Library/pull/159
   * @param privateKeyWith0x : private key with 0x prefix
   */
  var getAccountFrom0xPrivateKey = function (privateKeyWith0x) {
      var privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);
      var keyPair = secp256k1$1.keyFromPrivate(privateKeyWith0x, 'hex');
      var publicKeyWith0x = keyPair.getPublic(true, 'hex');
      var addressWith0x = getAddressFromPublicKey(publicKeyWith0x);
      var bech32With0x = toBech32Address(addressWith0x);
      var with0x = {
          prv: privateKeyWith0x,
          pub: publicKeyWith0x,
          addr: addressWith0x,
          bech32: bech32With0x,
      };
      var keyPair2 = secp256k1$1.keyFromPrivate(privateKeyWithout0x, 'hex');
      var publicKeyWithout0x = keyPair2.getPublic(true, 'hex');
      var addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);
      var bech32Without0x = toBech32Address(addressWithout0x);
      var without0x = {
          prv: privateKeyWithout0x,
          pub: publicKeyWithout0x,
          addr: addressWithout0x,
          bech32: bech32Without0x,
      };
      var privateKeyAfterChange = keyPair.getPrivate('hex');
      var publicKeyAfterChange = keyPair.getPublic(true, 'hex');
      var addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);
      var bech32AfterChange = toBech32Address(addressAfterChange);
      var changed = {
          prv: privateKeyAfterChange,
          pub: publicKeyAfterChange,
          addr: addressAfterChange,
          bech32: bech32AfterChange,
      };
      return {
          with0x: with0x,
          without0x: without0x,
          changed: changed,
      };
  };
  /**
   * compressPublicKey
   *
   * @param {string} publicKey - 65-byte public key, a point (x, y)
   *
   * @returns {string}
   */
  var compressPublicKey = function (publicKey) {
      return secp256k1$1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');
  };
  /**
   * getAddressFromPublicKey
   *
   * takes hex-encoded string and returns the corresponding address
   *
   * @param {string} pubKey
   * @returns {string}
   */
  var getAddressFromPublicKey = function (publicKey) {
      var normalized = publicKey.toLowerCase().replace('0x', '');
      return toChecksumAddress(hashjs
          .sha256()
          .update(normalized, 'hex')
          .digest('hex')
          .slice(24));
  };
  /**
   * toChecksumAddress
   *
   * takes hex-encoded string and returns the corresponding address
   *
   * @param {string} address
   * @returns {string}
   */
  var toChecksumAddress = function (address) {
      if (!util.validation.isAddress(address)) {
          throw new Error(address + " is not a valid base 16 address");
      }
      address = address.toLowerCase().replace('0x', '');
      var hash = hashjs
          .sha256()
          .update(address, 'hex')
          .digest('hex');
      var v = new util.BN(hash, 'hex', 'be');
      var ret = '0x';
      for (var i = 0; i < address.length; i++) {
          if ('0123456789'.indexOf(address[i]) !== -1) {
              ret += address[i];
          }
          else {
              ret += v.and(new util.BN(2).pow(new util.BN(255 - 6 * i))).gte(new util.BN(1))
                  ? address[i].toUpperCase()
                  : address[i].toLowerCase();
          }
      }
      return ret;
  };
  /**
   * isValidChecksumAddress
   *
   * takes hex-encoded string and returns boolean if address is checksumed
   *
   * @param {string} address
   * @returns {boolean}
   */
  var isValidChecksumAddress = function (address) {
      return (util.validation.isAddress(address.replace('0x', '')) &&
          toChecksumAddress(address) === address);
  };
  /**
   * normaliseAddress
   *
   * takes in a base16 address or a zilliqa bech32 encoded address
   * and returns a checksum base16 address. If the address is neither a base16
   * nor bech32 address, the code will return an error
   * @param {string)} address
   * @returns {string}
   */
  var normaliseAddress = function (address) {
      if (util.validation.isBech32(address)) {
          return fromBech32Address(address);
      }
      if (!isValidChecksumAddress(address)) {
          throw Error('Wrong address format, should be either bech32 or checksummed address');
      }
      return address;
  };
  /**
   * encodeBase58 - may be required for DID public key
   * undeprecating this function after version 2.0.0
   *
   * @param {string} hex - base 16 encoded string
   * @returns {string} - big endian base 58 encoded string
   */
  var encodeBase58 = function (hex) {
      var clean = hex.toLowerCase().replace('0x', '');
      var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      var base = new util.BN(58);
      var zero = new util.BN(0);
      var x = new util.BN(clean, 16);
      var res = '';
      while (x.gt(zero)) {
          var rem = x.mod(base).toNumber(); // safe, always < 58
          // big endian
          res = tbl[rem] + res;
          // quotient, remainders thrown away in integer division
          x = x.div(base);
      }
      // convert to big endian in case the input hex is little endian
      var hexBE = x.toString('hex', clean.length);
      for (var i = 0; i < hexBE.length; i += 2) {
          if (hex[i] === '0' && hex[i + 1] === '0') {
              res = tbl[0] + res;
          }
          else {
              break;
          }
      }
      return res;
  };
  /**
   * decodeBase58 - may be required for DID public key
   * undeprecating this function after version 2.0.0
   *
   * @param {string} raw - base 58 string
   * @returns {string} - big endian base 16 string
   */
  var decodeBase58 = function (raw) {
      var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      var base = new util.BN(58);
      var zero = new util.BN(0);
      var isBreak = false;
      var n = new util.BN(0);
      var leader = '';
      for (var i = 0; i < raw.length; i++) {
          var char = raw.charAt(i);
          var weight = new util.BN(tbl.indexOf(char));
          n = n.mul(base).add(weight);
          // check if padding required
          if (!isBreak) {
              if (i - 1 > 0 && raw[i - 1] !== '1') {
                  isBreak = true;
                  continue;
              }
              if (char === '1') {
                  leader += '00';
              }
          }
      }
      if (n.eq(zero)) {
          return leader;
      }
      var res = leader + n.toString('hex');
      if (res.length % 2 !== 0) {
          res = '0' + res;
      }
      return res;
  };
  /**
   * verifyPrivateKey
   *
   * @param {string|Buffer} privateKey
   * @returns {boolean}
   */
  var verifyPrivateKey = function (privateKey) {
      var keyPair = secp256k1$1.keyFromPrivate(privateKey, 'hex');
      var result = keyPair.validate().result;
      return result;
  };
  /**
   * normalizePrivateKey : normalise private key from 0x or without 0x prefix
   *
   * @param {string} privateKey
   * @returns {string}
   */
  var normalizePrivateKey = function (privateKey) {
      try {
          if (!util.validation.isPrivateKey(privateKey)) {
              throw new Error('Private key is not correct');
          }
          var normalized = privateKey.toLowerCase().replace('0x', '');
          if (!verifyPrivateKey(normalized)) {
              throw new Error('Private key is not correct');
          }
          return normalized;
      }
      catch (error) {
          throw error;
      }
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  //  Copyright (C) 2018 Zilliqa
  var ALGO_IDENTIFIER = 'aes-128-ctr';
  /**
   * getDerivedKey
   *
   * NOTE: only scrypt and pbkdf2 are supported.
   *
   * @param {Buffer} key - the passphrase
   * @param {KDF} kdf - the key derivation function to be used
   * @param {KDFParams} params - params for the kdf
   *
   * @returns {Promise<Buffer>}
   */
  function getDerivedKey(key, kdf, params) {
      return __awaiter(this, void 0, void 0, function () {
          var salt, _a, c, dklen, _b, n, r, p, dklen, derivedKeyInt8Array;
          return __generator(this, function (_c) {
              salt = Buffer.from(params.salt, 'hex');
              if (kdf === 'pbkdf2') {
                  _a = params, c = _a.c, dklen = _a.dklen;
                  return [2 /*return*/, pbkdf2.pbkdf2Sync(key, salt, c, dklen, 'sha256')];
              }
              if (kdf === 'scrypt') {
                  _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;
                  derivedKeyInt8Array = scrypt.syncScrypt(key, salt, n, r, p, dklen);
                  return [2 /*return*/, Buffer.from(derivedKeyInt8Array)];
              }
              throw new Error('Only pbkdf2 and scrypt are supported');
          });
      });
  }
  /**
   * encryptPrivateKey
   *
   * Encodes and encrypts an account in the format specified by
   * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.
   * However, note that, in keeping with the hash function used by Zilliqa's
   * core protocol, the MAC is generated using sha256 instead of keccak.
   *
   * NOTE: only scrypt and pbkdf2 are supported.
   *
   * @param {KDF} kdf - the key derivation function to be used
   * @param {string} privateKey - hex-encoded private key
   * @param {string} passphrase - a passphrase used for encryption
   *
   * @returns {Promise<string>}
   */
  var encryptPrivateKey = function (kdf, privateKey, passphrase) { return __awaiter(void 0, void 0, void 0, function () {
      var address, salt, iv, kdfparams, derivedKey, cipher, ciphertext;
      return __generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  address = getAddressFromPrivateKey(privateKey);
                  salt = randomBytes(32);
                  iv = Buffer.from(randomBytes(16), 'hex');
                  kdfparams = {
                      salt: salt,
                      n: 8192,
                      c: 262144,
                      r: 8,
                      p: 1,
                      dklen: 32,
                  };
                  return [4 /*yield*/, getDerivedKey(Buffer.from(passphrase), kdf, kdfparams)];
              case 1:
                  derivedKey = _a.sent();
                  cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));
                  ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey, 'hex')));
                  return [2 /*return*/, JSON.stringify({
                          address: address,
                          crypto: {
                              cipher: ALGO_IDENTIFIER,
                              cipherparams: {
                                  iv: iv.toString('hex'),
                              },
                              ciphertext: ciphertext.toString('hex'),
                              kdf: kdf,
                              kdfparams: kdfparams,
                              mac: hashjs
                                  // @ts-ignore
                                  .hmac(hashjs.sha256, derivedKey, 'hex')
                                  .update(Buffer.concat([
                                  derivedKey.slice(16, 32),
                                  ciphertext,
                                  iv,
                                  Buffer.from(ALGO_IDENTIFIER),
                              ]), 'hex')
                                  .digest('hex'),
                          },
                          id: uuid.v4({ random: util.bytes.hexToIntArray(randomBytes(16)) }),
                          version: 3,
                      })];
          }
      });
  }); };
  /**
   * decryptPrivateKey
   *
   * Recovers the private key from a keystore file using the given passphrase.
   *
   * @param {string} passphrase
   * @param {KeystoreV3} keystore
   * @returns {Promise<string>}
   */
  var decryptPrivateKey = function (passphrase, keystore) { return __awaiter(void 0, void 0, void 0, function () {
      var ciphertext, iv, kdfparams, derivedKey, mac, cipher;
      return __generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');
                  iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');
                  kdfparams = keystore.crypto.kdfparams;
                  return [4 /*yield*/, getDerivedKey(Buffer.from(passphrase), keystore.crypto.kdf, kdfparams)];
              case 1:
                  derivedKey = _a.sent();
                  mac = hashjs
                      // @ts-ignore
                      .hmac(hashjs.sha256, derivedKey, 'hex')
                      .update(Buffer.concat([
                      derivedKey.slice(16, 32),
                      ciphertext,
                      iv,
                      Buffer.from(ALGO_IDENTIFIER),
                  ]), 'hex')
                      .digest('hex');
                  // we need to do a byte-by-byte comparison to avoid non-constant time side
                  // channel attacks.
                  if (!util.bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {
                      return [2 /*return*/, Promise.reject('Failed to decrypt.')];
                  }
                  cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));
                  return [2 /*return*/, Buffer.from(cipher.decrypt(ciphertext)).toString('hex')];
          }
      });
  }); };

  //  Copyright (C) 2018 Zilliqa
  /**
   * sign
   *
   * @param {string} hash - hex-encoded hash of the data to be signed
   *
   * @returns {string} the signature
   */
  var sign$1 = function (msg, privateKey, pubKey) {
      var sig = sign(msg, Buffer.from(privateKey, 'hex'), Buffer.from(pubKey, 'hex'));
      var r = sig.r.toString('hex');
      var s = sig.s.toString('hex');
      while (r.length < 64) {
          r = '0' + r;
      }
      while (s.length < 64) {
          s = '0' + s;
      }
      return r + s;
  };

  exports.sign = sign$1;
  exports.schnorr = schnorr;
  exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
  exports.getPubKeyFromPrivateKey = getPubKeyFromPrivateKey;
  exports.getAccountFrom0xPrivateKey = getAccountFrom0xPrivateKey;
  exports.compressPublicKey = compressPublicKey;
  exports.getAddressFromPublicKey = getAddressFromPublicKey;
  exports.toChecksumAddress = toChecksumAddress;
  exports.isValidChecksumAddress = isValidChecksumAddress;
  exports.normaliseAddress = normaliseAddress;
  exports.encodeBase58 = encodeBase58;
  exports.decodeBase58 = decodeBase58;
  exports.verifyPrivateKey = verifyPrivateKey;
  exports.normalizePrivateKey = normalizePrivateKey;
  exports.encryptPrivateKey = encryptPrivateKey;
  exports.decryptPrivateKey = decryptPrivateKey;
  exports.randomBytes = randomBytes;
  exports.Signature = Signature;
  exports.encode = encode;
  exports.decode = decode;
  exports.HRP = HRP;
  exports.convertBits = convertBits;
  exports.toBech32Address = toBech32Address;
  exports.fromBech32Address = fromBech32Address;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
