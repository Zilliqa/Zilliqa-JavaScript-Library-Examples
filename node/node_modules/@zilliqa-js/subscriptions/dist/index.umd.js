(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('websocket')) :
    typeof define === 'function' && define.amd ? define(['exports', 'websocket'], factory) :
    (factory((global.zjsSubscriptions = {}),global.websocket));
}(this, (function (exports,websocket) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    //      
    // An event handler can take an optional event argument
    // and should not return a value
                                              
                                                                   

    // An array of all currently registered event handlers for a type
                                                
                                                                
    // A map of event types and their corresponding event handlers.
                            
                                     
                                       
      

    /** Mitt: Tiny (~200b) functional event emitter / pubsub.
     *  @name mitt
     *  @returns {Mitt}
     */
    function mitt(all                 ) {
    	all = all || Object.create(null);

    	return {
    		/**
    		 * Register an event handler for the given type.
    		 *
    		 * @param  {String} type	Type of event to listen for, or `"*"` for all events
    		 * @param  {Function} handler Function to call in response to given event
    		 * @memberOf mitt
    		 */
    		on: function on(type        , handler              ) {
    			(all[type] || (all[type] = [])).push(handler);
    		},

    		/**
    		 * Remove an event handler for the given type.
    		 *
    		 * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
    		 * @param  {Function} handler Handler function to remove
    		 * @memberOf mitt
    		 */
    		off: function off(type        , handler              ) {
    			if (all[type]) {
    				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
    			}
    		},

    		/**
    		 * Invoke all handlers for the given type.
    		 * If present, `"*"` handlers are invoked after type-matched handlers.
    		 *
    		 * @param {String} type  The event type to invoke
    		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
    		 * @memberOf mitt
    		 */
    		emit: function emit(type        , evt     ) {
    			(all[type] || []).slice().map(function (handler) { handler(evt); });
    			(all['*'] || []).slice().map(function (handler) { handler(type, evt); });
    		}
    	};
    }

    //  Copyright (C) 2018 Zilliqa
    (function (SocketConnect) {
        SocketConnect["READY"] = "ready";
        SocketConnect["CONNECT"] = "connect";
        SocketConnect["ERROR"] = "error";
        SocketConnect["CLOSE"] = "close";
        SocketConnect["RECONNECT"] = "reconnect";
    })(exports.SocketConnect || (exports.SocketConnect = {}));
    (function (SocketState) {
        SocketState["SOCKET_CONNECT"] = "socket_connect";
        SocketState["SOCKET_MESSAGE"] = "socket_message";
        SocketState["SOCKET_READY"] = "socket_ready";
        SocketState["SOCKET_CLOSE"] = "socket_close";
        SocketState["SOCKET_ERROR"] = "socket_error";
    })(exports.SocketState || (exports.SocketState = {}));
    (function (MessageType) {
        MessageType["NEW_BLOCK"] = "NewBlock";
        MessageType["EVENT_LOG"] = "EventLog";
        MessageType["NOTIFICATION"] = "Notification";
        MessageType["UNSUBSCRIBE"] = "Unsubscribe";
    })(exports.MessageType || (exports.MessageType = {}));
    (function (QueryParam) {
        QueryParam["NEW_BLOCK"] = "NewBlock";
        QueryParam["EVENT_LOG"] = "EventLog";
        QueryParam["UNSUBSCRIBE"] = "Unsubscribe";
    })(exports.QueryParam || (exports.QueryParam = {}));
    (function (StatusType) {
        StatusType["SUBSCRIBE_NEW_BLOCK"] = "SubscribeNewBlock";
        StatusType["SUBSCRIBE_EVENT_LOG"] = "SubscribeEventLog";
    })(exports.StatusType || (exports.StatusType = {}));

    //  Copyright (C) 2018 Zilliqa
    var WebSocketProvider = /** @class */ (function () {
        // basically, options is a collection of metadata things like protocol or headers
        function WebSocketProvider(url, options) {
            this.handlers = {};
            this.url = url;
            this.options = options;
            this.emitter = new mitt(this.handlers);
            this.websocket = WebSocketProvider.NewWebSocket(url, options);
            this.subscriptions = {};
            this.registerEventListeners();
        }
        WebSocketProvider.NewWebSocket = function (url, options) {
            // tslint:disable-next-line: no-string-literal
            if (typeof window !== 'undefined' && window.WebSocket) {
                // tslint:disable-next-line: no-string-literal
                return new WebSocket(url, options !== undefined ? options.protocol : []);
            }
            else {
                var headers = options !== undefined ? options.headers || {} : undefined;
                var urlObject = new URL(url);
                if (headers !== undefined &&
                    !headers.authorization &&
                    urlObject.username &&
                    urlObject.password) {
                    var authToken = Buffer.from(urlObject.username + ":" + urlObject.password).toString('base64');
                    headers.authorization = "Basic " + authToken;
                }
                return new websocket.w3cwebsocket(url, options !== undefined ? options.protocol : undefined, undefined, headers, undefined, options !== undefined ? options.clientConfig : undefined);
            }
        };
        WebSocketProvider.prototype.registerEventListeners = function () {
            this.websocket.onopen = this.onConnect.bind(this);
            this.websocket.onclose = this.onClose.bind(this);
            this.websocket.onmessage = this.onMessage.bind(this);
            this.websocket.onerror = this.onError.bind(this);
        };
        WebSocketProvider.prototype.removeAllSocketListeners = function () {
            this.removeEventListener(exports.SocketState.SOCKET_MESSAGE);
            this.removeEventListener(exports.SocketState.SOCKET_READY);
            this.removeEventListener(exports.SocketState.SOCKET_CLOSE);
            this.removeEventListener(exports.SocketState.SOCKET_ERROR);
            this.removeEventListener(exports.SocketState.SOCKET_CONNECT);
        };
        WebSocketProvider.prototype.removeEventListener = function (type, handler) {
            if (!type) {
                this.handlers = {};
                return;
            }
            if (!handler) {
                delete this.handlers[type];
            }
            else {
                return this.emitter.off(type, handler);
            }
        };
        WebSocketProvider.prototype.reconnect = function () {
            var _this = this;
            setTimeout(function () {
                _this.removeAllSocketListeners();
                _this.websocket = WebSocketProvider.NewWebSocket(_this.url, _this.options);
                _this.registerEventListeners();
            }, 5000);
        };
        WebSocketProvider.prototype.onClose = function (event) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    // reconnect
                    if (this.subscriptions !== null && !event.wasClean) {
                        this.emitter.emit(exports.SocketConnect.RECONNECT, event);
                        this.reconnect();
                        return [2 /*return*/];
                    }
                    // normal close
                    if (this.websocket.CONNECTING) {
                        this.emitter.emit(exports.SocketConnect.CLOSE, event);
                        this.websocket.close();
                        return [2 /*return*/];
                    }
                    return [2 /*return*/];
                });
            });
        };
        WebSocketProvider.prototype.onError = function (event) {
            this.emitter.emit(exports.SocketConnect.ERROR, event);
            if (this.websocket.CONNECTING) {
                this.websocket.close();
            }
            return;
        };
        WebSocketProvider.prototype.onConnect = function () {
            return __awaiter(this, void 0, void 0, function () {
                var subscriptionKeys, subscriptionKeys_1, subscriptionKeys_1_1, key, id, parameters, e_1_1;
                var e_1, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.subscriptions) {
                                this.subscriptions = {};
                            }
                            subscriptionKeys = Object.keys(this.subscriptions);
                            if (!(subscriptionKeys.length > 0)) return [3 /*break*/, 8];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 6, 7, 8]);
                            subscriptionKeys_1 = __values(subscriptionKeys), subscriptionKeys_1_1 = subscriptionKeys_1.next();
                            _b.label = 2;
                        case 2:
                            if (!!subscriptionKeys_1_1.done) return [3 /*break*/, 5];
                            key = subscriptionKeys_1_1.value;
                            id = key;
                            parameters = this.subscriptions[key].parameters;
                            delete this.subscriptions[id];
                            return [4 /*yield*/, this.subscribe(parameters)];
                        case 3:
                            _b.sent();
                            _b.label = 4;
                        case 4:
                            subscriptionKeys_1_1 = subscriptionKeys_1.next();
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_1_1 = _b.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (subscriptionKeys_1_1 && !subscriptionKeys_1_1.done && (_a = subscriptionKeys_1.return)) _a.call(subscriptionKeys_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 8:
                            this.emitter.emit(exports.SocketState.SOCKET_CONNECT);
                            this.emitter.emit(exports.SocketConnect.CONNECT);
                            return [2 /*return*/];
                    }
                });
            });
        };
        WebSocketProvider.prototype.onMessage = function (msg) {
            var e_2, _a;
            if (msg.data) {
                var dataObj = JSON.parse(msg.data);
                if (dataObj.type === exports.MessageType.NOTIFICATION) {
                    this.emitter.emit(exports.SocketState.SOCKET_MESSAGE, dataObj);
                    try {
                        for (var _b = __values(dataObj.values), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var value = _c.value;
                            if (value.query === exports.MessageType.NEW_BLOCK) {
                                this.emitter.emit(exports.MessageType.NEW_BLOCK, value);
                            }
                            else if (value.query === exports.MessageType.EVENT_LOG) {
                                this.emitter.emit(exports.MessageType.EVENT_LOG, value);
                            }
                            else if (value.query === exports.MessageType.UNSUBSCRIBE) {
                                this.emitter.emit(exports.MessageType.UNSUBSCRIBE, value);
                            }
                            else {
                                throw new Error('unsupported value type');
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                else if (dataObj.query === exports.QueryParam.NEW_BLOCK) {
                    // subscribe NewBlock succeed
                    this.subscriptions[dataObj.query] = {
                        id: dataObj.query,
                        parameters: dataObj,
                    };
                    this.emitter.emit(exports.StatusType.SUBSCRIBE_NEW_BLOCK, dataObj);
                    this.emitter.emit(exports.SocketConnect.RECONNECT);
                }
                else if (dataObj.query === exports.QueryParam.EVENT_LOG) {
                    // subscribe EventLog succeed
                    this.subscriptions[dataObj.query] = {
                        id: dataObj.query,
                        parameters: dataObj,
                    };
                    this.emitter.emit(exports.StatusType.SUBSCRIBE_EVENT_LOG, dataObj);
                    this.emitter.emit(exports.SocketConnect.RECONNECT);
                }
                else if (dataObj.query === exports.QueryParam.UNSUBSCRIBE) {
                    this.emitter.emit(exports.MessageType.UNSUBSCRIBE, dataObj);
                }
                else {
                    throw new Error('unsupported message type');
                }
            }
            else {
                throw new Error('message data is empty');
            }
        };
        WebSocketProvider.prototype.addEventListener = function (type, handler) {
            this.emitter.on(type, handler);
        };
        WebSocketProvider.prototype.connecting = function () {
            return this.websocket.readyState === this.websocket.CONNECTING;
        };
        WebSocketProvider.prototype.send = function (query) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this.connecting()) {
                    try {
                        _this.websocket.send(JSON.stringify(query));
                    }
                    catch (error) {
                        throw error;
                    }
                    var queryParam = void 0;
                    if (query.query === exports.QueryParam.NEW_BLOCK) {
                        queryParam = exports.StatusType.SUBSCRIBE_NEW_BLOCK;
                    }
                    else if (query.query === exports.QueryParam.EVENT_LOG) {
                        queryParam = exports.StatusType.SUBSCRIBE_EVENT_LOG;
                    }
                    else {
                        queryParam = query.query;
                    }
                    _this.emitter.on(queryParam, function (data) {
                        resolve(data);
                    });
                    _this.emitter.on(exports.SocketConnect.ERROR, reject);
                }
                var connectHandler = function () {
                    _this.send(query)
                        .then(resolve)
                        .catch(reject);
                };
                var offConnectHandler = function () {
                    _this.emitter.off(exports.SocketConnect.CONNECT, connectHandler);
                };
                _this.emitter.on(exports.SocketConnect.CONNECT, connectHandler);
                _this.emitter.on(exports.SocketConnect.RECONNECT, offConnectHandler);
            });
        };
        WebSocketProvider.prototype.subscribe = function (payload) {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.send(payload)];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result.query === payload.query];
                    }
                });
            });
        };
        WebSocketProvider.prototype.unsubscribe = function (payload) {
            return __awaiter(this, void 0, void 0, function () {
                var result, succeed;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.send(payload)];
                        case 1:
                            result = _a.sent();
                            succeed = result.query === payload.query;
                            if (succeed) {
                                this.subscriptions[payload.query] = null;
                            }
                            return [2 /*return*/, succeed];
                    }
                });
            });
        };
        return WebSocketProvider;
    }());

    //  Copyright (C) 2018 Zilliqa
    var Subscription = /** @class */ (function (_super) {
        __extends(Subscription, _super);
        function Subscription(subject, url, options) {
            var _this = _super.call(this, url, options) || this;
            _this.subject = subject;
            return _this;
        }
        Subscription.prototype.start = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, _super.prototype.subscribe.call(this, this.subject)];
                });
            });
        };
        Subscription.prototype.stop = function () {
            return __awaiter(this, void 0, void 0, function () {
                var event;
                return __generator(this, function (_a) {
                    event = this.subject.query === exports.QueryParam.NEW_BLOCK
                        ? {
                            query: exports.QueryParam.UNSUBSCRIBE,
                            type: exports.QueryParam.NEW_BLOCK,
                        }
                        : { query: exports.QueryParam.UNSUBSCRIBE, type: exports.QueryParam.EVENT_LOG };
                    return [2 /*return*/, _super.prototype.unsubscribe.call(this, event)];
                });
            });
        };
        return Subscription;
    }(WebSocketProvider));

    //  Copyright (C) 2018 Zilliqa
    var NewTxBlockSubscription = /** @class */ (function (_super) {
        __extends(NewTxBlockSubscription, _super);
        function NewTxBlockSubscription(url, options) {
            return _super.call(this, { query: exports.QueryParam.NEW_BLOCK }, url, options) || this;
        }
        return NewTxBlockSubscription;
    }(Subscription));

    //  Copyright (C) 2018 Zilliqa
    var NewEventSubscription = /** @class */ (function (_super) {
        __extends(NewEventSubscription, _super);
        function NewEventSubscription(url, options) {
            var _this = _super.call(this, { query: exports.QueryParam.EVENT_LOG }, url, options) || this;
            _this.subject = {
                query: 'EventLog',
                addresses: options !== undefined ? options.addresses : [],
            };
            return _this;
        }
        return NewEventSubscription;
    }(Subscription));

    //  Copyright (C) 2018 Zilliqa
    var SubscriptionBuilder = /** @class */ (function () {
        function SubscriptionBuilder() {
        }
        SubscriptionBuilder.prototype.buildNewBlockSubscriptions = function (url, options) {
            return new NewTxBlockSubscription(url, options);
        };
        SubscriptionBuilder.prototype.buildEventLogSubscriptions = function (url, options) {
            return new NewEventSubscription(url, options);
        };
        return SubscriptionBuilder;
    }());

    //  Copyright (C) 2018 Zilliqa

    exports.NewTxBlockSubscription = NewTxBlockSubscription;
    exports.Subscription = Subscription;
    exports.WebSocketProvider = WebSocketProvider;
    exports.NewEventSubscription = NewEventSubscription;
    exports.SubscriptionBuilder = SubscriptionBuilder;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
